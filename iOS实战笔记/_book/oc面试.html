<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>oc面试 | 我有勇气面对和足够的努力去争取我想要的</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 1.0.3">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    
    <link rel="next" href="./autolayout.html" />
    
    
    <link rel="prev" href="./Swift语法部分.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="gitbook/style.css">


        
    <div class="book"  data-level="3" data-basepath="." data-revision="1459612490209">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
    	
    	
    	

        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="./index.html">
                        <i class="fa fa-check"></i>
                        
                         The best of best
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="UI部分.html">
            
                
                    <a href="./UI部分.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         UI部分
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="1.1" data-path="基础常识.html">
            
                
                    <a href="./基础常识.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.1.</b>
                        
                         基础常识
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.2" data-path="关键字（面试）.html">
            
                
                    <a href="./关键字（面试）.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.2.</b>
                        
                         关键字（面试）
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.3" data-path="ui.html">
            
                
                    <a href="./ui.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.3.</b>
                        
                         UI控件使用注意
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    
        
        <li class="chapter " data-level="2" data-path="Swift语法部分.html">
            
                
                    <a href="./Swift语法部分.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                         Swift语法部分
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="3" data-path="oc面试.html">
            
                
                    <a href="./oc面试.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                         oc面试
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4" data-path="autolayout.html">
            
                
                    <a href="./autolayout.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                         AutoLayout
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="5" data-path="uitableview.html">
            
                
                    <a href="./uitableview.html">
                        <i class="fa fa-check"></i>
                        
                            <b>5.</b>
                        
                         UITableView&amp;UIScrollView
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="6" data-path="uialertcontroller.html">
            
                
                    <a href="./uialertcontroller.html">
                        <i class="fa fa-check"></i>
                        
                            <b>6.</b>
                        
                         UIAlertController
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="7" data-path=".html">
            
                
                    <a href="./.html">
                        <i class="fa fa-check"></i>
                        
                            <b>7.</b>
                        
                         Timer定时器、延迟
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="8" data-path="nsnotificationdelegateblock.html">
            
                
                    <a href="./nsnotificationdelegateblock.html">
                        <i class="fa fa-check"></i>
                        
                            <b>8.</b>
                        
                         NSNotification/Delegate/Block
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="9" data-path="animations.html">
            
                
                    <a href="./animations.html">
                        <i class="fa fa-check"></i>
                        
                            <b>9.</b>
                        
                         Animations
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="10" data-path="tips.html">
            
                
                    <a href="./tips.html">
                        <i class="fa fa-check"></i>
                        
                            <b>10.</b>
                        
                         tips-开发小技巧
                    </a>
                
            
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Published using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle share dropdown"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">Twitter</button>
                <button type="button" data-sharing="google-plus" class="button">Google</button>
                <button type="button" data-sharing="facebook" class="button">Facebook</button>
                <button type="button" data-sharing="weibo" class="button">Weibo</button>
                <button type="button" data-sharing="instapaper" class="button">Instapaper</button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="./" >我有勇气面对和足够的努力去争取我想要的</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_139">
                    
                        <h1 id="oc">OC语法（面试）</h1>
<p>OC是面向对象的，将功能封装进对象，强调了具备功能的对象，关注的是解决问题需要哪些对象，将复杂的问题简单化；C是面向过程的，强调的是解决问题需要哪些步骤，什么都要亲力亲为</p>
<pre><code class="lang-objc"><span class="hljs-preprocessor">#成员变量作用域修饰符</span>
<span class="hljs-number">1</span>、protected：默认就是这个，实例变量能被声明他的类和其子类进行访问
<span class="hljs-number">2</span>、private：只能在声明的类中进行访问,其他类和子类都不可以访问
<span class="hljs-number">3</span>、package：介于private和public之间，如果是在其他包中访问那么就是私有的，如果是在当前代码所在的包中访问就是public
<span class="hljs-number">4</span>、在<span class="hljs-variable">.h</span>文件中，无论是private/public/protected/package修饰成员变量，我们都可以在其他类中看到这个变量，只不过有的不可以
操作，但是在<span class="hljs-variable">.m</span>文件中，声明的实例变量，默认就是私有的，而且和private不同的地方在于，该成员变量在其他类中也无法查看，只能在本类中访问.
<span class="hljs-number">5</span>、如果只有方法的实现而没有声明，那么该方法就是私有方法，在oc中没有真正的私有方法，因为oc是消息机制，会进行动态绑定，会在运行的时候才会确定对象的真实类型或者去查看有没有这个方法
</code></pre>
<pre><code class="lang-objc"><span class="hljs-preprocessor"># @class</span>
提高编译效率；可以简单的引用一个类，它仅仅告诉编译器Dog是一个类，而不会包含Dog这个类的所有内容，也就是编译器并不知道这个类中有哪些属性和方法！
这个也就是它和<span class="hljs-preprocessor">#import（预编译指令，会在将代码翻译成0和1之前把引用的类文件内容直接拷贝一份到引用的地方）的区别；</span>
<span class="hljs-comment">//@class:两个应用场景</span>
<span class="hljs-number">1</span>、<span class="hljs-class"><span class="hljs-keyword">@class</span>使用在.<span class="hljs-title">h</span>文件中，#<span class="hljs-title">import</span>使用在.<span class="hljs-title">m</span>中，并且#<span class="hljs-title">import</span>有一个特点，只要“”中的文件发生了变化，那么#<span class="hljs-title">import</span>就会重新拷贝一次，如果都在.<span class="hljs-title">h</span>中#<span class="hljs-title">import</span>，</span>
假如A拷贝了B，B拷贝了C，如果C被修改了，那么A和B都需要重新拷贝，但是如果在<span class="hljs-variable">.h</span>中用<span class="hljs-class"><span class="hljs-keyword">@class</span>，.<span class="hljs-title">m</span>中使用#<span class="hljs-title">import</span>，如</span>
果一个文件发生了变化，只有和这个文件有直接关系的那个文件才会重新拷贝
<span class="hljs-number">2</span>、当A引用B，B中又引用A的时候，如果在<span class="hljs-variable">.h</span>文件中使用<span class="hljs-preprocessor">#import会造成循环拷贝</span>
这种死循环的情况，会报无法识别该类的错误，但是使用<span class="hljs-class"><span class="hljs-keyword">@class</span>则不会出现错误，不会循环拷贝</span>
</code></pre>
<pre><code class="lang-objc"><span class="hljs-preprocessor">#autorelease</span>
<span class="hljs-comment">//好处：不用关心对象什么时候释放，只要能够访问对象的地方都可以使用该对象，多个池子是以栈的形式存在的（先进后出），它的本质是延迟release操作</span>
<span class="hljs-comment">//注意：不要在池子中存放占内存比较大的对象，而且尽量也不要在池子中使用循环</span>
<span class="hljs-number">1</span>、对一个对象发送autoreleas消息，会将这个对象放入自动释放池，然后在这个池子销毁的时候自动向对象发送release消息，如果有多个池子，对象加入哪个池子就在哪个池子销毁时接收release消息，在同一个池子中如果对一个对象发送多次autoreleas消息，那么在池子销毁时就会进行多次的release操作，这样容易造成野指针。
<span class="hljs-number">2</span>、在一个自动释放池pool中，如果对象person调用了A方法，恰好在A方法中创建了一个student对象，而且student对象接收了一个autoreleas消息，那么相当于把student对象添加到了外面的那个pool池子中，在pool池子销毁时，会对student对象发送一个release操作
<span class="hljs-number">3</span>、通过以下类工厂方法创建的对象，系统会自动把该对象加入自动释放池，而且在系统自带的Foundation框架里面的类，通过类工厂方法创建的对象都是会自动把该对象加入自动释放池的
+Person{
    <span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> alloc]init autorelease];
 }
alloc init方法创建的才需要我们自己销毁
</code></pre>
<p><code>#@property   编译器指令</code></p>
<pre><code>1.在xcode4.4之前（@property int age），用它声明一个变量，编译器会自动生成该属性的getter/setter的声明，需要配合@synthesize使用，它会自动帮我们生成对应属性的实现
2. @property增强：在xcode4.4之后，只要利用一个@property，就可以同时生成一个属性的getter/setter方法的声明和实现，此时没有告诉系统需要将传入的值赋值给谁，那么系统默认会赋值给_下划线开头的成员变量（系统会自动给我们生成一个下划线开头的成员变量，并且默认是私有变量，相当于是在.m中生成的不是在.h中生成的
3．@property有一个弊端，它只会生成最简单的getter/setter方法的声明和实现，并不会对传入的值进行过滤，如果需要过滤，那么需要我们自己重写存取方法，如果重写了getter，那么@property只会帮我们生成setter，反之同理，如果同时重写存取方法，那么系统不会帮我们生成下划线开头的成员变量
4. @property修饰符
ARC是编译器特性，xcode的一个功能，不是运行时特性，它的判断准则是一个对象只要没有强指针指着，对象就会被释放，默认情况下所有指针都是强指针
    retain：修饰对象，写上这个属性，系统就会帮我们自动生成set/get方法的内存管理代码，如图-内存管理set方法
</code></pre><p><img src="images/内存管理set方法.png" alt=""></p>
<pre><code class="lang-objc"> ，对象引用计数会加<span class="hljs-number">1</span>，在MRC中使用
<span class="hljs-keyword">strong</span>：对应MRC中的retain，强引用，只有OC对象才能够使用该属性，一个对象只要有强指针指着，就不会被释放，有<span class="hljs-number">2</span>个指针指向同一个内存地址的意思

<span class="hljs-keyword">copy</span>：会在内存里拷贝一份对象，<span class="hljs-number">2</span>个指针指向不同的内存地址，只要是拷贝的对象，内容和之前的对象里面的内容是一样的，一个对象的修改不能影响另一个对象里面的东西，使用<span class="hljs-keyword">copy</span>生成的对象都是不可变的，使用mutablecopy生成的对象都是可变的，除了使用不可变的对象调用<span class="hljs-keyword">copy</span>方法不会生成新对象之外，其他都会生成新对象
浅拷贝：不会生成新对象，也是指针拷贝，因为无论是之前的还是之后的对象都是不可变的
深拷贝：会生成新的对象，本质就是创建一个新的内容
<span class="hljs-comment">//copy内存管理：因为浅拷贝不会生成新的对象，所以它会对之前的对象进行一次retain操作，因为深拷贝会生成新的对象，所以不会对原有对象再一次进行retain但是会对新的对象进行一次retain操作</span>
<span class="hljs-comment">//字符串需要使用copy修饰：就是防止字符串被别人任意修改，防止外界修改内部的数据</span>
<span class="hljs-comment">//block需要使用copy修饰：（这里使用copy并不是拷贝的意思，而是转移）</span>
情景<span class="hljs-number">1</span>：person类里面定义了一个block，block里面用到了dog类的对象
dog对象在block调用之前提前销毁，block里面访问到了dog对象，后续调用block的时候就会报错，所以使用<span class="hljs-keyword">copy</span>修饰它就是防止这个现象，block默认在栈中，如果使用<span class="hljs-keyword">copy</span>就会从栈转移到堆，并对它里面的对象发送一条retain消息，这样可以保证在调用block之前保住dog对象的命，后续如果person对象释放了，在person类的dealloc方法中需要对bloc发送一条release消息，这时block里面的对象都会进行一次release，防止内存泄露
block在使用<span class="hljs-keyword">copy</span>修饰之后引发的循环引用：（本类自己定义的block，block里面用到了本类自己）
情景：person类里面定义了一个属性name和一个block，block里面访问到了person里面的name属性 ，此时需要使用__block修饰对象
block里面访问到了name属性，在MRC中，是person对象的引用计数增加，使用__block可以不让它的引用计数增加，在ARC中是，你指着我，我指着你，都无法释放，使用__<span class="hljs-keyword">weak</span>解决
自定义类的<span class="hljs-keyword">copy</span>实现：遵守协议，实现方法，方法中遵守<span class="hljs-keyword">copy</span>原则，生成新对象，给新对象属性赋值，返回新对象，如图
</code></pre>
<p><code>如图</code></p>
<p><img src="images/自定义类实现copy.png" alt=""></p>
<pre><code class="lang-objc"><span class="hljs-keyword">assign</span>：不会帮我们生成set内存管理方法，只会生成普通的set/get方法，默认什么都不写就是这个，适用于基本数据类型：<span class="hljs-built_in">NSInteger</span>、<span class="hljs-built_in">CGFloat</span>和C数据类型 <span class="hljs-keyword">int</span>、<span class="hljs-keyword">float</span>等！<span class="hljs-keyword">assign</span>其实也可以修饰对象，之所以我们不使用它是因为使用<span class="hljs-keyword">assign</span>修饰的对象在释放后，指针地址还是存在的，指针并没有被置<span class="hljs-literal">nil</span>，容易造成野指针
<span class="hljs-keyword">weak</span>：对应MRC中的<span class="hljs-keyword">assign</span>，用于oc对象，代理和UI控件，只是单纯引用某个对象，但是并未拥有该对象，<span class="hljs-keyword">weak</span>修饰的对象在释放后指针会被置<span class="hljs-literal">nil</span>
<span class="hljs-comment">//UI控件使用weak的原因：UI控件之所以可以使用弱指针，是因为控制器有强指针指向UIView，UIView有强指针指向Subviews数组，数组中又有强指针指向控件，只要uiview不被释放，数组就不会被释放，控件就一直有强指针指着，所以只需使用weak就足够了，不必再次使用strong</span>
</code></pre>
<p><code>详细如图所示：</code></p>
<p><img src="images/UI控件使用weak原因.jpg" alt=""></p>
<pre><code class="lang-objc">delegate使用<span class="hljs-keyword">weak</span>的原因：指明该对象不拥有代理这个对象，让外界去控制代理的死活，避免循环引用，代理循环引用举例，人有一条狗，狗里面有一个代理，狗的代理又是人，如图-代理用<span class="hljs-keyword">weak</span>的原因，必须让代理用<span class="hljs-keyword">weak</span>，才可以保证p释放的时候，person和dog可以释放
</code></pre>
<p><code>如图：</code></p>
<p><img src="images/代理用weak的原因.JPG" alt=""></p>
<pre><code class="lang-objc"><span class="hljs-keyword">weak</span>修饰的对象销毁的时候，指针会自动设置为<span class="hljs-literal">nil</span> 而<span class="hljs-keyword">assign</span>不会，<span class="hljs-keyword">assign</span>可以用于非OC对象，而<span class="hljs-keyword">weak</span>必须用于OC对象

atomic：保证多线程安全，即多线程中只能有一个线程同时对它进行访问。需要消耗大量资源，性能低，默认就是这个，原子性操作，只有一扇门，一次只能通过一个人，前一个没过去，后一个人就需要等，atomic只给setter方法上锁，getter不会加锁
原子性操作指的就是不能被中断，要么执行完要么不执行
<span class="hljs-keyword">nonatomic</span>：性能高，<span class="hljs-number">99</span>%使用这个，非原子性操作，非线程完全，多个线程可以同时对其进行访问，相当于多扇门一次能过多个人 ，一般都是放弃安全，提高性能
</code></pre>
<pre><code class="lang-objc"><span class="hljs-preprocessor">#@synthesize  编译器指令（@synthesize age=_age）</span>
<span class="hljs-number">1.</span>    在<span class="hljs-keyword">@synthesize</span>后面告诉编译器，需要实现哪一个<span class="hljs-keyword">@property</span>生成的声明；
<span class="hljs-number">2.</span>    需要告诉<span class="hljs-keyword">@synthesize</span>，需要将传入的值赋值给谁/返回谁的值给调用者
<span class="hljs-number">3.</span>    如果在<span class="hljs-keyword">@synthesize</span>后面没有告诉系统需要将传入的值赋值给谁，那么系统默认会赋值给和<span class="hljs-keyword">@synthesize</span>后面名称一样的成员变量
</code></pre>
<p><code>id和instancetype</code></p>
<pre><code>父类类型的指针指向子类（多态）
1.id==NSObject *，万能指针，NSObject *属于静态数据类型（编译的时候就知道了它的属性和方法），不能调用子类特有的方法，而id属于动态数据类型，可以调用子类特有的方法，而且还可以调用私有方法，但是id虽好，
不可乱用，因为容易不小心调用到不属于自己的方法，编译器不会报错，造成运行时的错误，id一般使用在多态的情况下，可以在调用子类特有的方法的时候省去强制类型转换，减少代码量
2.instancetype万能指针，id可作为返回值，可定义一个变量，可以作为形参，而instancetype只可以作为返回值，而且instancetype可以在编译的时候判断对象的真实类型，id只可以在运行时判断
</code></pre><p><code>isKindOfClass/isMemberOfClass</code></p>
<pre><code>[obj isKindOfClass [student class]]，判断obj是否是student类或者它的子类的实例对象，
[obj isMemberOfClass [student class]] 判断obj是否是student类的实例对象
</code></pre><p><code>类的本质---isa指针</code></p>
<p><img src="images/图--类的本质.png" alt="">
<img src="images/图--类的存储细节.png" alt=""></p>
<pre><code class="lang-objc">类的load和initialize方法
<span class="hljs-number">2</span>个方法都是有且仅会调用一次，load方法是程序启动将类的代码加载到内存的时候就会调用，initialize方法是第一次使用到这个类的（创建类对象）时候会被调用，它多用于对一个类进行一次性的初始化操作，如果存在继承关系，在load中，先调用父类的load再调用子类
的load，如果一个类没有实现load方法，那么就不会调用它父类的load方法，在initialize方法中，也是先调用父类的再调用子类的，但是如果一个子类没有实现initialize方法，而父类实现了，那么也会调用父类的initialize方法，但是创建子类对象时会导致调用<span class="hljs-number">2</span>次父类的initialize方法，为了避免多次调用，需要在initialize方法中进行判断，
如果<span class="hljs-keyword">self</span>==[Parent class],再作出反应，这样就不会因为创建子类对象而调用到父类的initialize方法了。
</code></pre>
<pre><code class="lang-objc">Category（分类）
<span class="hljs-number">1</span>、    在不修改原有类的基础上对类进行方法扩展，它区别于继承，我们可以向任何已有的类添加成员函数来实现功能上的扩展，只允许添加成员函数，不能添加成员变量(如果用property修饰的成员变量，只会生成变量的set/get方法声明，并不会有实现也不会生成对应的私有成员变量)，而且成员函数可以访问原有类中的所有成员变量，该类的子类也将继承新添加的成员函数。
<span class="hljs-number">2</span>、    可以把原有类中的类进行功能拆分，让具有类似功能的类一起作为做一个分类，进行归类（模块化）管理，这样有利于程序员管理代码以及有利于多人开发
<span class="hljs-number">3</span>、    如果分类中有和原有类同名的方法，会调用分类中的方法（开发中尽量不要命名相同），如果多个分类中都有和原有类同名的方法，那么谁最后编译就先调用谁
</code></pre>
<pre><code class="lang-objc">Extension（匿名分类，也就是类扩展，它算是category的一个特例，即没有名字的category）
可以为某个类扩充一些私有的成员变量和方法，好处在于封装性，它就是我们开发中经常写在<span class="hljs-variable">.m</span>文件中的<span class="hljs-class"><span class="hljs-keyword">@interface</span>里面的东西</span>
</code></pre>
<pre><code class="lang-objc">Block
<span class="hljs-number">1</span>、类似于c语言的函数指针，返回值 （^名称）（参数），<span class="hljs-keyword">void</span> (^block)(),block=^(){};
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> (^calculteBlock) (<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span> );给block起别名，然后再定义的时候直接calculteBlock sum即可，sum=^(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b){}；
<span class="hljs-number">2</span>、__block修饰符：当在block中需要修改外部的变量时使用，（在block定义里面如果访问到了外界的局部变量，就会将外部变量<span class="hljs-keyword">copy</span>一份到堆内存中，所以block中的变量和外界的变量不是同一份，所以在block被调用之前修改外部变量的值，不会影响到block中拷贝的值），不加__block的情况，block内部访问外部变量a，其实相当于是把a作为一个参数进行传递的，又因为a是基本数据类型，而基本数据类型作为参数传递实质是值传递，所以内部修改不会影响到外部
加上__block后，把a传递的时候是传的a的地址，也就是实质是地址传递，所以在内部修改会影响到外部
<span class="hljs-number">3</span>、block循环引用解决：__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) NewName = <span class="hljs-keyword">self</span>(弱引用)，如图-block解决<span class="hljs-keyword">strong</span>
<span class="hljs-number">4</span>、block默认情况下是存储在栈中，block访问了外部的对象，不会对对象进行retain，如果对其进行<span class="hljs-keyword">copy</span>，那么它会转移到堆中，那么block内部如果访问到了外部的对象，会对其retain，所以如果在block内部访问了外部的对象，一定要给外部对象加上__block，这样即使blcok在堆中，也不会对对象进行retain
<span class="hljs-number">5</span>、block默认会在栈中，可能被随时回收，它的作用范围就在它定义时候的代码块内部，这个时候如果在其他作用域调用block就会崩溃，如果使用<span class="hljs-keyword">copy</span>修饰的话，可以将block转移到堆中，保住block的命，让它可以在其他作用域使用
</code></pre>
<pre><code class="lang-objc">Protocol 协议
<span class="hljs-number">1</span>、做类型限定，一个对象只有遵守了这个协议，才符合我的要求
<span class="hljs-number">2</span>、代理，之所以使用<span class="hljs-keyword">id</span>修饰，是因为这样可以让任何对象都可以成为我的代理，只要遵守我的协议即可，代理方法里面第一个参数之所以需要传当前类原因是提高规范，谁触发这个协议就把谁传出去，代理方法是当前类里面的，所以肯定由当前类触发
</code></pre>
<pre><code class="lang-objc">常量
<span class="hljs-built_in">NSString</span> *str=@”lb”;这个方式创建的就是字符串常量，保存在常量区，常量区有一个特点就是不会存在重复内容，所以有多个指针指向一样的内容的时候，指针保存的地址都是一样的
</code></pre>
<pre><code class="lang-objc">Error
一般在开发中使用error时，是需要一个指向指针的指针，<span class="hljs-built_in">NSError</span> *error=<span class="hljs-literal">nil</span>；然后将&amp;error传入进去（在函数中修改外部的对象，需要地址才可以修改），最后如果需要打印error信息，可以使用error的localizedDescription方法打印关键信息
</code></pre>
<pre><code class="lang-objc">URL
统一资源定位符，如果是访问本机的资源，建议创建url的时候都使用fileURLWithPath，因为url本身不支持中文，如果不使用这个方式创建，那么如果访问的文件夹路径有中文，那么就无法访问（但是并不代表一定不可以，可以使用字符串的stringByAdding…方法进行转换然后使用），如果使用这个方法就可以正常访问，系统会帮我们自动转换。另外如果使用了fileURLWithPath，那么path中就不需要再写协议头了，而且可以省略主机地址
</code></pre>
<pre><code class="lang-objc">NSString字符串一些注意点
rangeofstring字符串截取:
NSString *url=@“&lt;body&gt;来自苹果6 &lt;/body&gt;”；
NSRange range=[ url rangeOfString:@"&gt; "];
Range是一个结构体，里面有location（code=这个字符串在url这个字符串中的起始位置，从0开始，如果不存在返回NSNotFoung）和length（需要截取的字符串长度），配合subStringWithRange使用比较多,其中rangeOfString方法后面还可以添加一个参数，options：NSBackwardsSearch，这个参数指定从后往前找
if (range.length!=0) {
NSInteger location=range.location+1;
    NSInteger length= [url rangeOfString@”&lt;/”].location- range.location-1;
NSRange *range= NSMakeRang{ location , length };
NSString *str=[url subStringWithRange:range];
｝
除了上述方法可以获得我们想要的字符串，还可以使用以下2个方法合并使用来截取我们想要的字符串。substringFromindex，从哪一个位置开始截取到最后，substringToindex，从头开始截取到哪
//[str pathExtension]获取文件路径的扩展名比如txt，gif，png
//oc字符串还可以利用UTF8String方法转为C语言字符串，C语言字符串可以利用stringWithUTF8String转为oc字符串
转为oc字符串
//isEqualToString，比较2个字符串str1和str2内容是否相同，而str1==str2，是比较2个字符串地址是否相同
//compare，比较2个字符串的大小，实质是比较ASC||值
</code></pre>
<pre><code class="lang-objc"><span class="hljs-built_in">NSFileManager</span>
<span class="hljs-comment">//它的功能比较多，例如创建文件夹creatDirectory；创建文件creatFile；</span>
<span class="hljs-comment">//判断一个文件夹是否存在fileExistsAtPath；</span>
<span class="hljs-comment">//获取文件或者文件夹的属性（创建时间，大小等）attributesOfItemAtPath；</span>
<span class="hljs-comment">//获取文件夹中所有的文件contentsOfDirectoryAtPath(有弊端，只可以获得当前文件夹，不可以获得其子文件夹),但是使用subpathsAtPath方法就可以完整取得所有文件夹；清除缓存功能就是利用这个操作的,先获得所有文件，然后获取每一个文件的大小，最后逐个相加</span>
</code></pre>
<pre><code class="lang-objc">单例模式：（http:<span class="hljs-comment">//www.jianshu.com/p/7486ebfcd93b,</span>
规则：在ARC中，声明一个生成单例对象的类方法，一般都是share或者<span class="hljs-keyword">default</span>开头，定义一个全局实例，并重写allcoWithZone，copywithzone以及mutualcopywithzone方法，在allcoWithZone方法中控制使用多线程保证对象只存在一次即可，调用父类的allcoWithZone返回实例，在<span class="hljs-keyword">copy</span>的<span class="hljs-number">2</span>个方法中直接返回这个全局实例，这样无论是通过allco或者单例类方法或者<span class="hljs-keyword">copy</span>方法创建的对象都是同一个。
在MRC中，因为原则是alloc或者<span class="hljs-keyword">copy</span>一次需要就会retain，后续需要进行对应的release，而且retainCount会加<span class="hljs-number">1</span>，但是由于这个对象是需要全局使用，只可以在程序结束销毁，所以可以重写retain和release以及retainCount方法，只不过在retain里面直接返回实例，在release里面什么也不做，在retainCount中直接返回<span class="hljs-number">1</span>就行了，但是为了程序员之间方便沟通，一般不写<span class="hljs-number">1</span>，而是直接返回一个比较大的值（MAXFLOAT），一看这么大，就明白不需要retain了，再去retain就是有病啦！比较大的值一般在常量区，释放不了
<span class="hljs-comment">//2次判断是否为空最安全，简书里面仅判断一次，最好在加锁之前先做一次判断,这次判断是否为空的目的是防止频繁加锁）</span>
单例模式的作用：可以保证在程序运行过程中，一个类只有一个实例（而且这个类是有且仅能实例化一个对象的类），而且该实例易于供外界访问，从而方便地控制了实例个数，并节约系统资源。比如游戏中子弹的声音，需要经常使用，所以只创建一份比较好
单例模式的使用场合：在整个应用程序中，共享一份资源（这份资源只需要创建初始化<span class="hljs-number">1</span>次），应该让这个类创建出来的对象永远只有一个。
为什么要给单例对象加锁？
给单例对象之所以要加锁,是因为系统对于单例对象的内存申请是在堆区,而不是栈区,而我们在调用的时候一般是在栈区去执行它,也就是说每一个线程都可以调用它,而我们知道堆区的内存是有共享性的,为了保证单例对象的唯一性,避免不会在同一时间被调用,我们给他采用的加锁;
</code></pre>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="./Swift语法部分.html" class="navigation navigation-prev " aria-label="Previous page: Swift语法部分"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="./autolayout.html" class="navigation navigation-next " aria-label="Next page: AutoLayout"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
