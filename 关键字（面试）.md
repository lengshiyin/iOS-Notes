#####--->当我们想全局共用一些数据时，可以用宏、变量、常量---<
#const关键字的使用
const用来定义常量，它修饰谁，谁的值就不能被改变，可以保证安全性，
- int age=100，这里age是一个变量
- const int age =100和int const age =100都代表age是一个常量，常量在定义的时候必须给他初始化赋值，因为常量一旦定义后，不能再修改它的值

```objc
  const int *p1=&age //*p1是常量,p1指向的空间里面的值不可改变

  const int *p2=&age//*p2是常量,p2指向的空间里面的值不可改变

  int * const p3=&age//p3是常量,p3保存的地址不可改，指向不可改

  NSString *name=@"libo",有时候为了保证name的值不可改变，我们定义
 的时候都是把name定义成字符串常量，NSString * const name=@"libo"
```
##  #define
```objc
#define SUM(v1,v2) ((v1)+(V2))//宏定义并不会做任何运算，只会进行替换
//条件编译一般和#define配合使用
//使用条件编译可以缩小应用程序的大小，因为普通的if会将所有的代码都编译到二进制中，而#if只会将满足条件的部分一直到下一个条件的部分编译到二进制中
//使用条件编译多用于调试和开发阶段进行测试
```

####define(宏)和const的比较
- 宏和const都可以定义一个值，在我们使用的时候直接使用；
- 宏是预编译指令，在程序编译成功之前，进行替换。没有类型，编译的时候不会进行类型检查，
比如#define age                       20，在后面程序中用到了这个age，那么系统就会提前在用到age的地方把age替换成20，在代码块内部访问，所以20是一个局部临时内存，如果多处用到20，那么系统就会分配多份局部临时内存；
- const int age=20，这里age是一个全局常量，在内存中只有一份存储空间，多次访问的都是同一份内存;
- 使用const修饰的常量可以用来保存一些字面值，在编译的时候就已经确定了，所以它不可以用来存储一些需要调用某些方法才可以确定的值，因为调用都是运行时才决定的，但是这个情况下可以使用宏进行定义

```objc
NSString * const emotionbtn=@"emotionbtn"//不可变的
#define LBRandomColor [UIColor colorWithRed:arc4random_uniform(256)/255.0 green:arc4random_uniform(256)/255.0 blue:arc4random_uniform(256)/255.0 alpha:1.0]//可变的
```
#static关键字的使用
修饰变量（全局变量[存储在静态区]和局部变量[存储在栈中]）
```objc
- 修饰全局：一个全局变量默认是整个程序所有文件都可以访问的（在外部访问的时候需要extern引用），如果加上static修饰，那么只可以在本类的文件中访问，外部访问不了，使用extern也不可以，安全性高
- 修饰局部：局部变量被static修饰后，它的生命周期和全局变量[类似]（永远只有一份内存，程序结束才会销毁），但是作用域并没有改变（还是只可以在当前代码块内访问），可以保证局部变量永远只初始化一次，在程序运行过程中，永远只有一份内存，但是它的存储空间会改变，会从栈中转移到静态区
*一般情况下，我们在代码块中使用static修饰局部变量，多用于这个局部变量值是固定的，而且经常被访问，因为不使用static的话，每一次访问局部变量都会重新申请内存，这样很耗性能，使用static的话，保证局部变量只有一份内存
```
修饰函数（作用：声明和定义一个内部函数，内部函数：只可以在本类中访问的函数，外部不能访问）
```objc
内部函数的声明：
static void test();
内部函数的定义：
static void test(){}
注意：在整个程序不同文件中，不可以有同名的外部函数，但是可以有同名的内部函数
```

#extern关键字的使用
修饰变量（全局变量）
- 声明/引用的意思
  - 由于全局变量整个内存中只可以有一份一样的，否则会报重复定义的错误(这个是xcode帮我们优化的)，如果我们需要在B文件中使用A文件里面的全局变量int age=10，那么需要先在B文件内进行引用，extern int age；让B文件明确表示我现在需要引用age，那么系统就会自动在整个文件中查询age，找到后返回；
 - 如果我们多个文件中都需要引用到age，那么我们就需要在每一个文件中使用到extern，这样显然是麻烦的，因此在实际开发中，我们经常这样做
```objc
1、首先需要建一个LBConst类（该类是存放项目中用到的全局常量），
在类的.m文件中进行定义，
#import <Foundation/Foundation.h>
NSString * const emotionbtn=@"emotionbtn";
.h文件中进行声明/引用
#import <Foundation/Foundation.h>
extern NSString * const emotionbtn;
2、在pch文件内#import引用，
#import "LBConst.h"
3、第二步以后，文件夹中的所有文件都已经包含了这个LBConst.h文件，后续哪一个类中需要使用到某一个或多个全局常量的时候，直接使用常量名就行了
```

修饰函数（作用：完整的声明和定义一个外部函数，外部函数：能够让程序的所有文件访问的函数）
```objc
#外部函数：默认所有的函数都是外部函数,
普通的外部函数定义：
void test(){};
完整的外部函数定义：//extern可省略
extern void test(){};
普通的外部函数声明：
void test();
完整的外部函数声明：//extern可省略
extern void test();
```
#import
```objc
1、是 Objective-C 导入头文件的关键字，完整地包含某个文件的内容，会将.h文件完整的拷贝一份替换#import<...>
2、只会导入一次，即使手动导入多次，也不也会重复导入
3、不会引发交叉编译; 因为在 Objective-C 中会存在C/C++和Objective-C 混编的问题，如果用 #include 引入头文件，会导致交叉编译。
4、#import<Foundation/Foundation.h>
OC中把工具箱划分了很多模块，每个模块里面都有很多头文件，这句话就是告诉编译去把Foundation这个子工具箱里面的Foundation.h文件拷贝到这里进行替换；
而C语言里面只有一个工具箱，所以直接写头文件就可以了
5、Foundation.h是主头文件，主头文件会导入该工具箱当中所有工具(类)的头文件，所以导入主头文件之后相当于导入了这个工具箱里面的所有头文件
```
#include
.h文件不会参与编译，.m文件才会
```objc
C/C++ 导入头文件的关键字，也是把文件内容完整的拷贝到当前#import的位置，然后替换#import，但是如果不写头文件卫士就无法防止重复导入
头文件卫士：在一个类的.h文件中
#ifndef 项目名称_类名_h  //或者__类名大写__H__
#define 项目名称_类名_h  //或者__类名大写__H__
代码(方法声明)
#endif
```
#import<> 和 import""
```objc
<> : 引用系统文件，它用于对系统自带的头文件的引用，编译器首先会在编译器(xcode)环境中找，找不到会去系统的编译环境中找.
 "": 用户自定义的文件用双引号引用，编译器首先会在当前文件所在的文件夹下查找，找不到会去开发工具的编译环境找，再找不到会去系统找
```
